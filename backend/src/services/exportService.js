import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const exportsDir = join(__dirname, '../../exports');

// Ensure exports directory exists
if (!fs.existsSync(exportsDir)) {
  fs.mkdirSync(exportsDir, { recursive: true });
}

const exportService = {
  sanitizeName(name) {
    return (name || 'export').replace(/[^a-zA-Z0-9_\-]/g, '_').replace(/_+/g, '_').substring(0, 50);
  },

  async generatePDF({ title, metadata, data, columns, sourceName }) {
    const suffix = Math.random().toString(36).substring(2, 6);
    const fileName = `${this.sanitizeName(sourceName)}_${suffix}.pdf`;
    const filePath = join(exportsDir, fileName);

    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50 });
      const stream = fs.createWriteStream(filePath);

      doc.pipe(stream);

      // Title
      doc.fontSize(20).font('Helvetica-Bold').text(title || 'Data Export', { align: 'center' });
      doc.moveDown();

      // Metadata
      doc.fontSize(10).font('Helvetica').fillColor('#666');
      doc.text(`Generated: ${new Date().toLocaleString()}`);
      if (metadata) {
        Object.entries(metadata).forEach(([key, value]) => {
          doc.text(`${key}: ${value}`);
        });
      }
      doc.moveDown();

      // Data table
      if (data && data.length > 0) {
        const cols = columns || Object.keys(data[0]);
        const colWidth = (doc.page.width - 100) / Math.min(cols.length, 5);
        const displayCols = cols.slice(0, 5);

        // Header
        doc.fontSize(9).font('Helvetica-Bold').fillColor('#333');
        let x = 50;
        displayCols.forEach(col => {
          doc.text(String(col).substring(0, 15), x, doc.y, { width: colWidth, continued: false });
          x += colWidth;
        });
        doc.moveDown(0.5);

        // Draw header line
        doc.moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke('#ccc');
        doc.moveDown(0.5);

        // Rows
        doc.font('Helvetica').fontSize(8).fillColor('#444');
        const maxRows = Math.min(data.length, 100);
        for (let i = 0; i < maxRows; i++) {
          if (doc.y > doc.page.height - 80) {
            doc.addPage();
          }
          x = 50;
          const row = data[i];
          displayCols.forEach(col => {
            const val = row[col] !== null && row[col] !== undefined ? String(row[col]).substring(0, 20) : '-';
            doc.text(val, x, doc.y, { width: colWidth, continued: false });
            x += colWidth;
          });
          doc.moveDown(0.3);
        }

        if (data.length > maxRows) {
          doc.moveDown();
          doc.fontSize(9).fillColor('#999').text(`... and ${data.length - maxRows} more rows`);
        }
      }

      // Footer
      doc.moveDown(2);
      doc.fontSize(8).fillColor('#999').text('Generated by AI Data Analyst', { align: 'center' });

      doc.end();

      stream.on('finish', () => {
        const stats = fs.statSync(filePath);
        resolve({ filePath, fileName, fileSize: stats.size });
      });
      stream.on('error', reject);
    });
  },

  async generateExcel({ title, metadata, data, columns, sourceName }) {
    const suffix = Math.random().toString(36).substring(2, 6);
    const fileName = `${this.sanitizeName(sourceName)}_${suffix}.xlsx`;
    const filePath = join(exportsDir, fileName);

    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'AI Data Analyst';
    workbook.created = new Date();

    const sheet = workbook.addWorksheet(title || 'Data Export');

    if (data && data.length > 0) {
      const cols = columns || Object.keys(data[0]);

      // Header row
      sheet.columns = cols.map(col => ({
        header: String(col),
        key: col,
        width: Math.max(String(col).length + 2, 12)
      }));

      // Style header
      const headerRow = sheet.getRow(1);
      headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
      headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF4F46E5' }
      };
      headerRow.alignment = { vertical: 'middle', horizontal: 'center' };

      // Data rows
      data.forEach(row => {
        const rowData = {};
        cols.forEach(col => {
          rowData[col] = row[col] !== null && row[col] !== undefined ? row[col] : '';
        });
        sheet.addRow(rowData);
      });

      // Auto-filter
      sheet.autoFilter = {
        from: { row: 1, column: 1 },
        to: { row: data.length + 1, column: cols.length }
      };

      // Freeze header row
      sheet.views = [{ state: 'frozen', ySplit: 1 }];
    }

    // Metadata sheet
    if (metadata) {
      const metaSheet = workbook.addWorksheet('Metadata');
      metaSheet.columns = [
        { header: 'Property', key: 'property', width: 20 },
        { header: 'Value', key: 'value', width: 40 }
      ];
      metaSheet.addRow({ property: 'Generated', value: new Date().toLocaleString() });
      Object.entries(metadata).forEach(([key, value]) => {
        metaSheet.addRow({ property: key, value: String(value) });
      });
    }

    await workbook.xlsx.writeFile(filePath);
    const stats = fs.statSync(filePath);
    return { filePath, fileName, fileSize: stats.size };
  },

  getFilePath(fileName) {
    return join(exportsDir, fileName);
  }
};

export default exportService;
